#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Janela principal do chat fofo WhatsApp
Integra√ß√£o completa com banco de dados em tempo real
"""

import sys
import os
from typing import Dict, List, Optional
from PyQt6.QtWidgets import QApplication, QMainWindow, QMessageBox
from PyQt6.QtCore import QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QIcon

# Importar nossos m√≥dulos
from ui.main_window_ui import MainWindowUI, ContactItemWidget
from ui.chat_widget import MessageRenderer, MessageBubble
from database import ChatDatabaseInterface


class DatabaseWorker(QThread):
    """Worker thread para opera√ß√µes do banco de dados"""

    # Sinais para comunica√ß√£o com a UI
    contacts_loaded = pyqtSignal(list)
    messages_loaded = pyqtSignal(list)
    error_occurred = pyqtSignal(str)
    connection_status_changed = pyqtSignal(bool)

    def __init__(self, db_interface: ChatDatabaseInterface):
        super().__init__()
        self.db_interface = db_interface
        self.current_task = None
        self.task_params = {}
        self.is_running = True

    def set_task(self, task_name: str, **params):
        """Define a tarefa a ser executada"""
        self.current_task = task_name
        self.task_params = params

    def run(self):
        """Executa a tarefa atual"""
        try:
            if not self.db_interface.is_connected():
                self.connection_status_changed.emit(False)
                self.error_occurred.emit("Banco de dados n√£o conectado")
                return

            self.connection_status_changed.emit(True)

            if self.current_task == "load_contacts":
                contacts = self.db_interface.get_contacts_list(50)
                self.contacts_loaded.emit(contacts)

            elif self.current_task == "load_messages":
                contact_id = self.task_params.get('contact_id')
                if contact_id:
                    messages = self.db_interface.get_chat_messages(contact_id, 100)
                    self.messages_loaded.emit(messages)
                else:
                    self.error_occurred.emit("ID do contato n√£o fornecido")

        except Exception as e:
            self.error_occurred.emit(f"Erro na opera√ß√£o: {str(e)}")

    def stop(self):
        """Para o worker thread"""
        self.is_running = False
        self.quit()
        self.wait()


class WhatsAppChatWindow(QMainWindow):
    """Janela principal do chat fofo"""

    def __init__(self):
        super().__init__()

        # Inicializar banco de dados
        self.db_interface = ChatDatabaseInterface()

        # Configurar UI
        self.ui = MainWindowUI(self)

        # Worker thread para banco
        self.db_worker = DatabaseWorker(self.db_interface)
        self.setup_database_connections()

        # Estado atual
        self.current_contact = None
        self.current_contact_data = None
        self.loaded_contacts = {}

        # Timer para atualiza√ß√µes autom√°ticas
        self.refresh_timer = QTimer()
        self.refresh_timer.timeout.connect(self.auto_refresh)
        self.refresh_timer.start(30000)  # A cada 30 segundos

        # Conectar sinais da UI
        self.setup_ui_connections()

        # Carregar dados iniciais
        self.load_initial_data()

    def setup_database_connections(self):
        """Configura conex√µes com o worker do banco"""
        self.db_worker.contacts_loaded.connect(self.on_contacts_loaded)
        self.db_worker.messages_loaded.connect(self.on_messages_loaded)
        self.db_worker.error_occurred.connect(self.on_database_error)
        self.db_worker.connection_status_changed.connect(self.on_connection_status_changed)

    def setup_ui_connections(self):
        """Configura conex√µes da interface"""
        # Bot√£o de refresh no cabe√ßalho do chat
        self.ui.refresh_btn.clicked.connect(self.refresh_current_chat)

        # Busca de contatos
        self.ui.search_input.textChanged.connect(self.filter_contacts)

        # Atalho de debug (Ctrl+D)
        from PyQt6.QtGui import QShortcut, QKeySequence
        debug_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        debug_shortcut.activated.connect(self.show_debug_info)

    def load_initial_data(self):
        """Carrega dados iniciais"""
        print("üì• Carregando lista de contatos...")
        self.ui.show_welcome_screen()

        if self.db_interface.is_connected():
            self.db_worker.set_task("load_contacts")
            self.db_worker.start()
        else:
            QMessageBox.warning(self, "Erro de Conex√£o",
                                "N√£o foi poss√≠vel conectar ao banco de dados.\n"
                                "Verifique se o arquivo existe em: backend/banco/whatsapp_webhook_realtime.db")

    def on_connection_status_changed(self, connected: bool):
        """Atualiza status de conex√£o na UI"""
        self.ui.update_connection_status(connected)

        if connected:
            print("‚úÖ Conectado ao banco de dados")
        else:
            print("‚ùå Desconectado do banco de dados")

    def on_contacts_loaded(self, contacts: List[Dict]):
        """Chamado quando contatos s√£o carregados"""
        print(f"üìã {len(contacts)} contatos carregados")

        # Limpar lista atual
        self.ui.clear_contacts_list()
        self.loaded_contacts.clear()

        # Adicionar contatos √† lista
        for contact_data in contacts:
            contact_widget = self.ui.add_contact_to_list(contact_data)
            contact_widget.clicked.connect(self.on_contact_selected)

            # Salvar refer√™ncia
            contact_id = contact_data['contact_id']
            self.loaded_contacts[contact_id] = contact_data

        print("‚úÖ Lista de contatos atualizada")

    def on_contact_selected(self, contact_id: str):
        """Chamado quando um contato √© selecionado"""
        if contact_id not in self.loaded_contacts:
            print(f"‚ö†Ô∏è Contato {contact_id} n√£o encontrado na lista")
            return

        contact_data = self.loaded_contacts[contact_id]

        print(f"üë§ Contato selecionado: {contact_data['contact_name']} ({contact_id})")

        # Atualizar estado atual
        self.current_contact = contact_id
        self.current_contact_data = contact_data

        # Atualizar UI
        self.ui.show_chat_screen()
        self.ui.update_active_contact(contact_data)
        self.ui.clear_messages()

        # Carregar mensagens
        print(f"üì® Carregando mensagens do chat...")
        self.db_worker.set_task("load_messages", contact_id=contact_id)

        # Aguardar thread anterior terminar se necess√°rio
        if self.db_worker.isRunning():
            self.db_worker.wait()

        self.db_worker.start()

    def on_messages_loaded(self, messages: List[Dict]):
        """Chamado quando mensagens s√£o carregadas"""
        if not self.current_contact:
            return

        print(f"üí¨ {len(messages)} mensagens carregadas para {self.current_contact}")

        # Limpar mensagens atuais
        self.ui.clear_messages()

        if not messages:
            # Nenhuma mensagem encontrada
            self.add_system_message("Nenhuma mensagem encontrada com este contato.")
            return

        # Renderizar mensagens com separadores de data
        previous_message = None

        for i, message_data in enumerate(messages):
            print(f"  Processando mensagem {i + 1}: {message_data.get('content', '')[:50]}...")

            # Verificar se precisa de separador de data
            if MessageRenderer.should_show_date_separator(message_data, previous_message):
                date_str = message_data.get('date_str', '')
                if date_str:
                    formatted_date = MessageRenderer.format_date_separator(date_str)
                    date_separator = MessageRenderer.create_date_separator(formatted_date)
                    self.add_widget_to_chat(date_separator)
                    print(f"    + Separador de data: {formatted_date}")

            # Criar e adicionar mensagem
            try:
                message_widget = MessageRenderer.create_message_widget(message_data)
                if message_widget:
                    self.add_widget_to_chat(message_widget)
                    print(f"    + Mensagem adicionada: {type(message_widget).__name__}")

                    # Animar entrada se for MessageBubble
                    if isinstance(message_widget, MessageBubble):
                        QTimer.singleShot(50 * i, message_widget.animate_in)
                else:
                    print(f"    ! Falha ao criar widget da mensagem")
            except Exception as e:
                print(f"    ‚ùå Erro ao criar mensagem: {e}")
                continue

            previous_message = message_data

        # Adicionar stretch no final para empurrar mensagens para cima
        self.ui.messages_layout.addStretch()

        # Atualizar geometria e rolar para o final
        self.ui.messages_widget.updateGeometry()
        self.ui.messages_scroll.updateGeometry()

        # Rolar para o final ap√≥s um pequeno delay
        QTimer.singleShot(200, self.ui.scroll_to_bottom)

        print(f"‚úÖ {len(messages)} mensagens renderizadas na interface")

    def on_database_error(self, error_message: str):
        """Chamado quando ocorre erro no banco"""
        print(f"‚ùå Erro no banco: {error_message}")

        # Mostrar erro na UI se for cr√≠tico
        if "conectar" in error_message.lower() or "banco" in error_message.lower():
            QMessageBox.critical(self, "Erro do Banco de Dados",
                                 f"Erro ao acessar banco de dados:\n{error_message}")

    def add_widget_to_chat(self, widget):
        """Adiciona widget √† √°rea de mensagens"""
        # Garantir que o widget seja vis√≠vel
        widget.setVisible(True)
        widget.show()

        # Adicionar ao layout
        self.ui.messages_layout.addWidget(widget)

        # For√ßar atualiza√ß√£o do layout
        self.ui.messages_widget.updateGeometry()
        self.ui.messages_scroll.updateGeometry()

        # Processar eventos pendentes
        from PyQt6.QtWidgets import QApplication
        QApplication.processEvents()

    def add_system_message(self, message: str):
        """Adiciona mensagem do sistema"""
        from PyQt6.QtWidgets import QLabel
        from PyQt6.QtCore import Qt
        from PyQt6.QtGui import QFont

        system_label = QLabel(message)
        system_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        system_label.setFont(QFont('Segoe UI', 10))
        system_label.setMinimumHeight(40)  # Altura m√≠nima
        system_label.setStyleSheet("""
            QLabel {
                color: #95a5a6;
                background-color: #f8f9fa;
                padding: 10px 20px;
                border-radius: 15px;
                margin: 10px 50px;
                font-style: italic;
            }
        """)

        # Garantir visibilidade
        system_label.setVisible(True)
        system_label.show()

        self.add_widget_to_chat(system_label)
        print(f"üìù Mensagem do sistema adicionada: {message}")

    def filter_contacts(self, search_text: str):
        """Filtra contatos baseado no texto de busca"""
        search_text = search_text.lower().strip()

        # Se busca vazia, mostrar todos
        if not search_text:
            for i in range(self.ui.contacts_list.count()):
                item = self.ui.contacts_list.item(i)
                item.setHidden(False)
            return

        # Filtrar contatos
        for i in range(self.ui.contacts_list.count()):
            item = self.ui.contacts_list.item(i)
            widget = self.ui.contacts_list.itemWidget(item)

            if isinstance(widget, ContactItemWidget):
                contact_data = widget.contact_data
                name = contact_data.get('contact_name', '').lower()
                contact_id = contact_data.get('contact_id', '').lower()

                # Verificar se corresponde √† busca
                should_show = (search_text in name or
                               search_text in contact_id or
                               search_text in contact_data.get('last_message', '').lower())

                item.setHidden(not should_show)

    def refresh_current_chat(self):
        """Atualiza o chat atual"""
        if self.current_contact:
            print(f"üîÑ Atualizando chat: {self.current_contact}")

            # Parar worker se estiver rodando
            if self.db_worker.isRunning():
                print("‚è≥ Aguardando thread anterior...")
                self.db_worker.wait()

            # Carregar mensagens novamente
            self.db_worker.set_task("load_messages", contact_id=self.current_contact)
            self.db_worker.start()
        else:
            # Atualizar lista de contatos
            print("üîÑ Atualizando lista de contatos")

            # Parar worker se estiver rodando
            if self.db_worker.isRunning():
                print("‚è≥ Aguardando thread anterior...")
                self.db_worker.wait()

            self.db_worker.set_task("load_contacts")
            self.db_worker.start()

    def auto_refresh(self):
        """Atualiza√ß√£o autom√°tica peri√≥dica"""
        # S√≥ atualizar se n√£o estiver fazendo outra opera√ß√£o
        if not self.db_worker.isRunning():
            # Se tem chat ativo, atualizar mensagens
            if self.current_contact:
                print("üîÑ Auto-refresh: atualizando mensagens")
                self.refresh_current_chat()
            else:
                # Sen√£o, atualizar lista de contatos
                print("üîÑ Auto-refresh: atualizando contatos")
                self.load_initial_data()
        else:
            print("‚è≥ Auto-refresh pulado - thread ocupada")

    def show_debug_info(self):
        """Mostra informa√ß√µes de debug"""
        if self.current_contact:
            layout_count = self.ui.messages_layout.count()
            print(f"üîç DEBUG INFO:")
            print(f"   Contato atual: {self.current_contact}")
            print(f"   Widgets no layout: {layout_count}")
            print(f"   √Årea de mensagens vis√≠vel: {self.ui.messages_widget.isVisible()}")
            print(f"   √Årea de scroll vis√≠vel: {self.ui.messages_scroll.isVisible()}")

            # Listar widgets no layout
            for i in range(layout_count):
                item = self.ui.messages_layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    print(f"   Widget {i}: {type(widget).__name__} - Vis√≠vel: {widget.isVisible()}")
        else:
            print("üîç DEBUG: Nenhum contato selecionado")

    def show_database_stats(self):
        """Mostra estat√≠sticas do banco de dados"""
        stats = self.db_interface.get_database_stats()

        if stats:
            stats_text = f"""
üìä Estat√≠sticas do Banco de Dados:

üìÅ Arquivo: {stats.get('database_path', 'N/A')}
üíæ Tamanho: {stats.get('database_size_mb', 0)} MB
üì® Total de eventos: {stats.get('total_events', 0):,}
üë• Total de remetentes: {stats.get('total_senders', 0):,}
üí¨ Total de chats: {stats.get('total_chats', 0):,}

üìÖ Primeira mensagem: {stats.get('first_message_date', 'N/A')}
üïê √öltima mensagem: {stats.get('last_message_date', 'N/A')}
            """

            QMessageBox.information(self, "Estat√≠sticas do Banco", stats_text)
        else:
            QMessageBox.warning(self, "Erro", "N√£o foi poss√≠vel obter estat√≠sticas do banco")

    def closeEvent(self, event):
        """Evento de fechamento da janela"""
        print("üëã Encerrando aplica√ß√£o...")

        # Parar timer
        self.refresh_timer.stop()

        # Parar worker thread
        if self.db_worker.isRunning():
            self.db_worker.stop()

        event.accept()


def main():
    """Fun√ß√£o principal"""
    # Criar aplica√ß√£o
    app = QApplication(sys.argv)

    # Configurar aplica√ß√£o
    app.setApplicationName("WhatsApp Chat Interface")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("Chat Analytics")

    # Configurar √≠cone se dispon√≠vel
    try:
        app.setWindowIcon(QIcon("icon.png"))
    except:
        pass

    # Verificar se arquivos necess√°rios existem
    required_files = [
        os.path.join('backend', 'banco', 'database_manager_updated.py'),
        os.path.join('backend', 'banco', 'models_updated.py')
    ]

    missing_files = []
    for file_path in required_files:
        if not os.path.exists(file_path):
            missing_files.append(file_path)

    if missing_files:
        print("‚ùå Arquivos necess√°rios n√£o encontrados:")
        for file in missing_files:
            print(f"   - {file}")
        print("\nüìÅ Estrutura esperada:")
        print("   projeto/")
        print("   ‚îú‚îÄ‚îÄ main_window.py")
        print("   ‚îú‚îÄ‚îÄ database.py")
        print("   ‚îú‚îÄ‚îÄ ui/")
        print("   ‚îÇ   ‚îú‚îÄ‚îÄ main_window_ui.py")
        print("   ‚îÇ   ‚îî‚îÄ‚îÄ chat_widget.py")
        print("   ‚îî‚îÄ‚îÄ backend/")
        print("       ‚îî‚îÄ‚îÄ banco/")
        print("           ‚îú‚îÄ‚îÄ models_updated.py")
        print("           ‚îú‚îÄ‚îÄ database_manager_updated.py")
        print("           ‚îî‚îÄ‚îÄ whatsapp_webhook_realtime.db")

        # Ainda assim tenta executar
        print("\n‚ö†Ô∏è Tentando executar mesmo assim...")

    # Criar e mostrar janela principal
    try:
        window = WhatsAppChatWindow()
        window.show()

        print("üéâ Interface do chat iniciada!")
        print("üí° Recursos dispon√≠veis:")
        print("   - Lista de contatos com busca")
        print("   - Visualiza√ß√£o de mensagens por contato")
        print("   - Design fofo com cores past√©is")
        print("   - Atualiza√ß√£o autom√°tica a cada 30 segundos")
        print("   - Suporte a todos os tipos de mensagem")
        print("\nüìù TODO - Funcionalidades futuras:")
        print("   - Envio de mensagens")
        print("   - Anexo de arquivos")
        print("   - Notifica√ß√µes de novas mensagens")

        # Executar aplica√ß√£o
        sys.exit(app.exec())

    except Exception as e:
        print(f"‚ùå Erro ao iniciar aplica√ß√£o: {e}")
        import traceback
        traceback.print_exc()


if __name__ == '__main__':
    main()

# =============================================================================
# üé® INTERFACE DE CHAT FOFA - WHATSAPP
# =============================================================================
#
# üìã ARQUIVOS NECESS√ÅRIOS:
# - main_window.py (este arquivo - controlador principal)
# - database.py (integra√ß√£o com banco)
# - ui/main_window_ui.py (layout da interface)
# - ui/chat_widget.py (bal√µes de mensagem fofos)
# - backend/banco/database_manager_updated.py (gerenciador do banco)
# - backend/banco/models_updated.py (modelos do banco)
# - backend/banco/whatsapp_webhook_realtime.db (banco SQLite)
#
# üöÄ COMO EXECUTAR:
# python main_window.py
#
# üéØ RECURSOS IMPLEMENTADOS:
# ‚úÖ Interface fofa com cores past√©is
# ‚úÖ Lista de contatos com busca
# ‚úÖ Bal√µes de mensagem estilo Messenger
# ‚úÖ Integra√ß√£o completa com banco SQLite
# ‚úÖ Suporte a todos os tipos de mensagem
# ‚úÖ Separadores de data autom√°ticos
# ‚úÖ Atualiza√ß√£o autom√°tica
# ‚úÖ Design responsivo
# ‚úÖ Anima√ß√µes suaves
# ‚úÖ Sombras e bordas arredondadas
#
# üîÆ TODO - PR√ìXIMAS FUNCIONALIDADES:
# üî≤ Envio de mensagens (campo desabilitado)
# üî≤ Anexo de arquivos (bot√£o desabilitado)
# üî≤ Notifica√ß√µes de novas mensagens
# üî≤ Busca dentro das mensagens
# üî≤ Export de conversas
# üî≤ Configura√ß√µes de tema
#
# üé® DESIGN:
# - Cores past√©is (azul, rosa, verde menta)
# - Bordas arredondadas em tudo
# - Sombras suaves nos bal√µes
# - √çcones fofos para tipos de m√≠dia
# - Avatares coloridos baseados no nome
# - Gradientes suaves nos cabe√ßalhos
#
# üì± TIPOS DE MENSAGEM SUPORTADOS:
# - üí¨ Texto/emoji
# - üè∑Ô∏è Stickers
# - üì∑ Imagens (com caption)
# - üé• V√≠deos (com caption)
# - üéµ √Åudios
# - üìÑ Documentos (com preview)
# - üìç Localiza√ß√µes (com nome/endere√ßo)
# - üìä Enquetes (com op√ß√µes)
#
# =============================================================================